package main

import (
	"flag"
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/pentops/o5-go/messaging/v1/messaging_pb"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/pluginpb"
)

const version = "1.0"

var extraHeadersString *string
var extraHeaders []keyValue

func main() {
	showVersion := flag.Bool("version", false, "print the version and exit")
	flag.Parse()
	if *showVersion {
		fmt.Printf("protoc-gen-go-messaging %v\n", version)
		return
	}

	var flags flag.FlagSet
	extraHeadersString = flags.String("extra_headers", "", ": separated key:val:key:val pairs to add to gRPC headers")

	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		extraHeaders = make([]keyValue, 0)

		if extraHeadersString == nil || *extraHeadersString == "" {
			// This breaks the 'pure function' ideal, but there doesn't appear to be any way to dynamically inject using buf
			str := os.Getenv("PROTOC_GEN_GO_MESSAGING_EXTRA_HEADERS")
			extraHeadersString = &str
		}

		if extraHeadersString != nil && *extraHeadersString != "" {
			parts := strings.Split(*extraHeadersString, ":")
			if len(parts)%2 != 0 {
				return fmt.Errorf("uneven number of extra_headers")
			}
			for x := 0; x < len(parts); x += 2 {
				extraHeaders = append(extraHeaders, keyValue{
					key: strings.TrimSpace(parts[x]),
					val: strings.TrimSpace(parts[x+1]),
				})
			}
		}

		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			if _, err := generateFile(gen, f); err != nil {
				return err
			}
		}
		return nil
	})
}

// generateFile generates a _messaging.pb.go file containing various mappings Messaging Over gRPC extensions
func generateFile(gen *protogen.Plugin, file *protogen.File) (*protogen.GeneratedFile, error) {
	if len(file.Services) == 0 {
		return nil, nil
	}
	filename := file.GeneratedFilenamePrefix + "_messaging.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-messaging. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	for _, service := range file.Services {
		if err := genServiceExtension(g, service); err != nil {
			return nil, err
		}
	}
	return g, nil
}

func getFieldForType(message *protogen.Message, typeName string) (*protogen.Field, error) {
	var foundField *protogen.Field
	for _, field := range message.Fields {

		msg := field.Desc.Message()
		if msg == nil {
			continue
		}
		if string(msg.FullName()) == typeName {
			if foundField != nil {
				return nil, fmt.Errorf("Multiple %s messages in %s", typeName, message.Desc.FullName())
			}
			foundField = field
		}
	}
	foundField, err := getOptionalFieldForType(message, typeName)
	if err != nil {
		return nil, err
	}
	if foundField == nil {
		return nil, fmt.Errorf("No %s messages in %s", typeName, message.Desc.FullName())
	}
	return foundField, nil
}

func getOptionalFieldForType(message *protogen.Message, typeName string) (*protogen.Field, error) {
	var foundField *protogen.Field
	for _, field := range message.Fields {

		msg := field.Desc.Message()
		if msg == nil {
			continue
		}
		if string(msg.FullName()) == typeName {
			if foundField != nil {
				return nil, fmt.Errorf("Multiple %s messages in %s", typeName, message.Desc.FullName())
			}
			foundField = field
		}
	}
	return foundField, nil
}

type keyValue struct {
	key string
	val string
}

func genServiceExtension(g *protogen.GeneratedFile, service *protogen.Service) error {
	g.P("// Service: " + service.GoName)

	for _, method := range service.Methods {
		g.P("// Method: " + method.GoName)
		g.P("")

		headers := append([]keyValue{
			{key: "grpc-service", val: fmt.Sprintf("/%s/%s", service.Desc.FullName(), method.Desc.FullName().Name())},
			{key: "grpc-message", val: string(method.Input.Desc.FullName())},
		}, extraHeaders...)

		messagingAnnotation, ok := proto.GetExtension(service.Desc.Options(), messaging_pb.E_Config).(*messaging_pb.Config)
		if ok && messagingAnnotation != nil {

			// OUTPUT:
			// func (msg *AddEntryMessage) MessagingTopic() string {
			//   return "... as defined"
			// }

			g.P("func (msg *", method.Desc.Input().Name(), ") MessagingTopic() string {")
			switch topicType := messagingAnnotation.Type.(type) {
			case *messaging_pb.Config_Broadcast:
				g.P("return \"", topicType.Broadcast.Name, "\"")

			case *messaging_pb.Config_Unicast:
				g.P("return \"", topicType.Unicast.Name, "\"")

			case *messaging_pb.Config_Reply:
				sagaReplyField, err := getFieldForType(method.Input, "messaging.v1.SagaReply")
				if err != nil {
					return err
				}
				g.P("return \"", topicType.Reply.Name, "_\" + msg.", sagaReplyField.GoName, ".ReplyQueue")

			default:
				return fmt.Errorf("unknown / unsupported topic type %v", topicType)
			}
			g.P("}")
		}

		g.P("func (msg *", method.Desc.Input().Name(), ") MessagingHeaders() map[string]string {")
		g.P("headers := map[string]string{")
		for _, header := range headers {
			g.P(`"`, header.key, `": "`, header.val, `",`)
		}
		g.P("}")

		upsertField, err := getOptionalFieldForType(method.Input, "messaging.v1.UpsertMetadata")
		if err != nil {
			return err
		}
		if upsertField != nil {
			g.P(`if msg.`, upsertField.GoName, ` != nil {`)
			g.P(`headers["grpc-upsert-entity-id"] = msg.`, upsertField.GoName, `.EntityId`)
			// cheating with RFC3339 string so we don't have to import time package in the generated code.
			g.P(`headers["grpc-upsert-entity-timestamp"] = msg.`, upsertField.GoName, `.Timestamp.AsTime().Format("`, time.RFC3339, `")`)
			g.P(`}`)
		}

		eventField, err := getOptionalFieldForType(method.Input, "messaging.v1.EventMetadata")
		if err != nil {
			return err
		}
		if eventField != nil {
			g.P(`if msg.`, upsertField.GoName, ` != nil {`)
			g.P(`headers["grpc-event-message-id"] = msg.`, upsertField.GoName, `.MessageId`)
			g.P(`}`)
		}

		g.P("return headers")
		g.P("}")
	}
	return nil
}

var boolVal = map[bool]string{
	true:  "true",
	false: "false",
}
