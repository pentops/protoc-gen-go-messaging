package main

import (
	"flag"
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/pentops/o5-go/messaging/v1/messaging_pb"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/pluginpb"
)

const version = "1.0"

var extraHeadersString *string
var extraHeaders []keyValue

func main() {
	showVersion := flag.Bool("version", false, "print the version and exit")
	flag.Parse()
	if *showVersion {
		fmt.Printf("protoc-gen-go-messaging %v\n", version)
		return
	}

	var flags flag.FlagSet
	extraHeadersString = flags.String("extra_headers", "", ": separated key:val:key:val pairs to add to gRPC headers")

	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		extraHeaders = make([]keyValue, 0)

		if extraHeadersString == nil || *extraHeadersString == "" {
			// This breaks the 'pure function' ideal, but there doesn't appear to be any way to dynamically inject using buf
			str := os.Getenv("PROTOC_GEN_GO_MESSAGING_EXTRA_HEADERS")
			extraHeadersString = &str
		}

		if extraHeadersString != nil && *extraHeadersString != "" {
			parts := strings.Split(*extraHeadersString, ":")
			if len(parts)%2 != 0 {
				return fmt.Errorf("uneven number of extra_headers")
			}
			for x := 0; x < len(parts); x += 2 {
				extraHeaders = append(extraHeaders, keyValue{
					key:  strings.TrimSpace(parts[x]),
					code: []interface{}{`"`, strings.TrimSpace(parts[x+1]), `"`},
				})
			}
		}

		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			if _, err := generateFile(gen, f); err != nil {
				return err
			}
		}
		return nil
	})
}

// generateFile generates a _messaging.pb.go file containing various mappings Messaging Over gRPC extensions
func generateFile(gen *protogen.Plugin, file *protogen.File) (*protogen.GeneratedFile, error) {
	if len(file.Services) == 0 {
		return nil, nil
	}
	filename := file.GeneratedFilenamePrefix + "_messaging.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-messaging. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	for _, service := range file.Services {
		if err := genServiceExtension(g, service); err != nil {
			return nil, err
		}
	}
	return g, nil
}

func getFieldForType(message *protogen.Message, typeName string) (*protogen.Field, error) {
	var foundField *protogen.Field
	for _, field := range message.Fields {

		msg := field.Desc.Message()
		if msg == nil {
			continue
		}
		if string(msg.FullName()) == typeName {
			if foundField != nil {
				return nil, fmt.Errorf("Multiple %s messages in %s", typeName, message.Desc.FullName())
			}
			foundField = field
		}
	}
	foundField, err := getOptionalFieldForType(message, typeName)
	if err != nil {
		return nil, err
	}
	if foundField == nil {
		return nil, fmt.Errorf("No %s messages in %s", typeName, message.Desc.FullName())
	}
	return foundField, nil
}

func getOptionalFieldForType(message *protogen.Message, typeName string) (*protogen.Field, error) {
	var foundField *protogen.Field
	for _, field := range message.Fields {

		msg := field.Desc.Message()
		if msg == nil {
			continue
		}
		if string(msg.FullName()) == typeName {
			if foundField != nil {
				return nil, fmt.Errorf("Multiple %s messages in %s", typeName, message.Desc.FullName())
			}
			foundField = field
		}
	}
	return foundField, nil
}

type keyValue struct {
	key  string
	code []interface{}
}

func genServiceExtension(g *protogen.GeneratedFile, service *protogen.Service) error {
	g.P("// Service: " + service.GoName)

	for _, method := range service.Methods {
		if err := genMethodExtension(g, service, method); err != nil {
			return err
		}
	}
	return nil
}

func genMethodExtension(g *protogen.GeneratedFile, service *protogen.Service, method *protogen.Method) error {
	g.P("// Method: " + method.GoName)
	g.P("")

	headers := append([]keyValue{
		{key: "grpc-service", code: []interface{}{`"/`, service.Desc.FullName(), `/`, method.Desc.Name(), `"`}},
		{key: "grpc-message", code: []interface{}{`"`, method.Input.Desc.FullName(), `"`}},
	}, extraHeaders...)

	messagingAnnotation, _ := proto.GetExtension(service.Desc.Options(), messaging_pb.E_Config).(*messaging_pb.Config)
	if messagingAnnotation == nil {
		return nil
	}

	// OUTPUT:
	// func (msg *AddEntryMessage) MessagingTopic() string {
	//   return "... as defined"
	// }

	var messagingTopic string
	switch topicType := messagingAnnotation.Type.(type) {
	case *messaging_pb.Config_Broadcast:
		messagingTopic = topicType.Broadcast.Name

	case *messaging_pb.Config_Unicast:
		messagingTopic = topicType.Unicast.Name

	case *messaging_pb.Config_Request:
		messagingTopic = topicType.Request.Name + "_request"
		sagaReplyField, err := getFieldForType(method.Input, "o5.messaging.v1.RequestMetadata")
		if err != nil {
			return err
		}
		headers = append(headers, keyValue{
			key: "o5-request-reply-to",
			code: []interface{}{
				`msg.`, sagaReplyField.GoName, `.ReplyTo`,
			},
		})

	case *messaging_pb.Config_Reply:
		messagingTopic = topicType.Reply.Name + "_reply"
		sagaReplyField, err := getFieldForType(method.Input, "o5.messaging.v1.RequestMetadata")
		if err != nil {
			return err
		}
		headers = append(headers, keyValue{
			key: "o5-reply-reply-to",
			code: []interface{}{
				`msg.`, sagaReplyField.GoName, `.ReplyTo`,
			},
		})

	default:
		return fmt.Errorf("unknown / unsupported topic type %v", topicType)
	}

	g.P("func (msg *", method.Desc.Input().Name(), ") MessagingTopic() string {")
	g.P("return \"", messagingTopic, "\"")
	g.P("}")

	g.P("func (msg *", method.Desc.Input().Name(), ") MessagingHeaders() map[string]string {")
	g.P("headers := map[string]string{")
	for _, header := range headers {
		codeLine := append([]interface{}{`"`, header.key, `": `}, header.code...)
		codeLine = append(codeLine, ",")
		g.P(codeLine...)
	}
	g.P("}")

	upsertField, err := getOptionalFieldForType(method.Input, "messaging.v1.UpsertMetadata")
	if err != nil {
		return err
	}
	if upsertField != nil {
		g.P(`if msg.`, upsertField.GoName, ` != nil {`)
		g.P(`headers["o5-upsert-entity-id"] = msg.`, upsertField.GoName, `.EntityId`)
		// cheating with RFC3339 string so we don't have to import time package in the generated code.
		g.P(`headers["o5-upsert-entity-timestamp"] = msg.`, upsertField.GoName, `.Timestamp.AsTime().Format("`, time.RFC3339, `")`)
		g.P(`}`)
	}

	g.P("return headers")
	g.P("}")
	g.P("")
	return nil
}

var boolVal = map[bool]string{
	true:  "true",
	false: "false",
}
